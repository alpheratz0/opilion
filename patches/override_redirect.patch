diff --git a/src/x11/window.c b/src/x11/window.c
index 5d12e35..5063e13 100644
--- a/src/x11/window.c
+++ b/src/x11/window.c
@@ -30,32 +30,47 @@ x11_get_atom(xcb_connection_t *conn, const char *name)
 	return atom;
 }
 
-static void
-window_set_fullscreen(xcb_connection_t *conn, xcb_window_t wid)
+static uint8_t
+window_grab_keyboard(xcb_connection_t *conn, xcb_screen_t *screen)
 {
-	xcb_atom_t net_wm_state, net_wm_state_fullscreen;
+	uint8_t status;
+	xcb_grab_keyboard_cookie_t cookie;
+	xcb_grab_keyboard_reply_t *reply;
+	xcb_generic_error_t *error;
 
-	net_wm_state = x11_get_atom(conn, "_NET_WM_STATE");
-	net_wm_state_fullscreen = x11_get_atom(conn, "_NET_WM_STATE_FULLSCREEN");
+	status = -1;
+	error = NULL;
 
-	xcb_change_property(
-		conn, XCB_PROP_MODE_REPLACE, wid,
-		net_wm_state, XCB_ATOM_ATOM, 32, 1, &net_wm_state_fullscreen
+	cookie = xcb_grab_keyboard(
+		conn, 0, screen->root, XCB_CURRENT_TIME,
+		XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC
+	);
+
+	reply = xcb_grab_keyboard_reply(
+		conn, cookie, &error
 	);
+
+	if (NULL != error) {
+		dief("xcb_grab_keyboard failed with error code: %d",
+				(int)(error->error_code));
+	}
+
+	status = reply->status;
+
+	free(reply);
+
+	return status;
 }
 
 static void
-window_enable_wm_delete_window(xcb_connection_t *conn, xcb_window_t wid)
+window_set_focus(xcb_connection_t *conn, xcb_window_t wid)
 {
-	xcb_atom_t wm_protocols, wm_delete_window;
-
-	wm_protocols = x11_get_atom(conn, "WM_PROTOCOLS");
-	wm_delete_window = x11_get_atom(conn, "WM_DELETE_WINDOW");
-
-	xcb_change_property(
-		conn, XCB_PROP_MODE_REPLACE, wid,
-		wm_protocols, XCB_ATOM_ATOM, 32, 1, &wm_delete_window
+	xcb_set_input_focus(
+		conn, XCB_INPUT_FOCUS_POINTER_ROOT,
+		wid, XCB_CURRENT_TIME
 	);
+
+	xcb_flush(conn);
 }
 
 static void
@@ -101,7 +116,7 @@ window_create(const char *title, const char *class)
 	xcb_image_t *image;
 	bitmap_t *bmp;
 	window_t *window;
-	uint32_t evmask;
+	uint32_t evmask[2];
 
 	if (xcb_connection_has_error((conn = xcb_connect(NULL, NULL)))) {
 		die("can't open display");
@@ -122,26 +137,29 @@ window_create(const char *title, const char *class)
 		(uint8_t *)(bmp->px)
 	);
 
-	evmask = XCB_EVENT_MASK_EXPOSURE |
-	         XCB_EVENT_MASK_KEY_PRESS |
-	         XCB_EVENT_MASK_KEY_RELEASE;
+	evmask[0] = 1;
+	evmask[1] = XCB_EVENT_MASK_EXPOSURE |
+	            XCB_EVENT_MASK_KEY_PRESS |
+	            XCB_EVENT_MASK_KEY_RELEASE;
 
 	xcb_create_window(
 		conn, XCB_COPY_FROM_PARENT, wid, screen->root, 0, 0, bmp->width,
 		bmp->height, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,
-		XCB_CW_EVENT_MASK, &evmask
+		XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK, evmask
 	);
 
 	xcb_create_gc(conn, gc, wid, 0, 0);
 
 	window_set_wm_name(conn, wid, title);
 	window_set_wm_class(conn, wid, class, class);
-	window_set_fullscreen(conn, wid);
-	window_enable_wm_delete_window(conn, wid);
 
 	xcb_map_window(conn, wid);
 	xcb_flush(conn);
 
+	window_grab_keyboard(conn, screen);
+	window_set_focus(conn, wid);
+	xcb_flush(conn);
+
 	if (NULL == (window = malloc(sizeof(window_t)))) {
 		die("error while calling malloc, no memory available");
 	}
